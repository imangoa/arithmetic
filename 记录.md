## 674.最长连续递增序列

```c++
    int findLengthOfLCIS(vector<int>& nums) {
        int count = 1;
        int max  =1;
        for (int i = 0; i < nums.size()-1; i++)
        {
            if (nums[i]<nums[i+1]){
                count++;
                max=max>count?max:count;
            }
            else{
                count=1;
            }
        }
        return max;
    }
```

### 记录

1. 处理的代码放在else里面，**要考虑else不执行情况。**

#### error code

```c++
    int findLengthOfLCIS(vector<int>& nums) {
        int count = 1;
        int max  =1;
        for (int i = 0; i < nums.size()-1; i++)
        {
            if (nums[i]<nums[i+1]){
                count++;
            }
            else{
               	max=max>count?max:count;
                count=1;
            }
        }
        return max;
    }
```

把	`max=max>count?max:count;` 放在else里面执行，一般情况能正常运行。但是如果 输入为类似`[1,2,3,4,5]`，则else不会执行，返回时max没有更新。


## 707 设计链表
1. 需要全面考虑多种情况
2. 代码error，下次重写！



### 509.斐波那契数

```cpp
    unordered_map<int,int> records;
    int fib(int n) {
        if (n==0)
            return 0;
        if (n==1)
            return 1;
        if (records.find(n)!=records.end())
            return records[n];
        
        int cur = fib(n-1)+fib(n-2);
        records[n]=cur;
        return cur;
        
    }
```

1. 斐波那契数列递归写法
   * 边界条件：n==0||n==1
   * 递推关系：fib(n)=fib(n-1)+fib(n-2)
   * 减少重复计算：records[n] 记录已经递归的值



### 206反转链表（递归）

#### 最初解法

```cpp
    ListNode* reverseList(ListNode* head) {
        if (head->next==nullptr)
            return head;
        ListNode* n =reverseList(head->next);
        head->next->next=head;
        return n;
    }
```

1. 没有考虑链表为空的情况 `if(head->next==nullptr||head==nullptr)`进行判断
2. 没有考虑到在头指针应该指向空，如果不写`head->next=nullptr`则会导致函数完成后，原头指针(反转后的尾指针)指向head->next。head->next指向head。
3. 记录尾指针，用来返回。

#### 正确解法

```cpp
ListNode* reverseList(ListNode* head){
    if(head->next==nullptr||head==nullptr)
        return head;
 	ListNode* n =reverseList(head->next);     //这句用来记录链表末尾值，在所有递归中一直返回的都是这个值。
	head->next->next=head;
    head->next = nullptr;
	return n;
}
```



## 并查集

https://www.yuque.com/u33623936/yve21f/urzwgnlsgprffi3q

